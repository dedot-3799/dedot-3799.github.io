<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
    <style>
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
        }

        #ot_app {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            border-radius: 10px;
        }

        #ot_board {
            display: grid;
            grid-template-columns: repeat(8, calc(80vmin / 8));
            grid-template-rows: repeat(8, calc(80vmin / 8));
            gap: 1px;
            background-color: #00ff00;
        }

        .ot_square {
            width: calc(80vmin / 8);
            height: calc(80vmin / 8);
            display: flex;
            border: 1px solid #888;
            justify-content: center;
            align-items: center;
            transition-duration: 500ms;
        }

        .ot_square.black {
            background-color: #000000;
            border-radius: 50%;
        }

        .ot_square.white {
            background-color: #ffffff;
            border-radius: 50%;
        }

        .ot_square.valid-1 {
            background-color: #a0c0ff;
            /* Light blue for 1 flip */
        }

        .ot_square.valid-2 {
            background-color: #80a0ff;
            /* Slightly darker blue for 2 flips */
        }

        .ot_square.valid-3 {
            background-color: #6080ff;
            /* Even darker blue for 3 flips */
        }

        .ot_square.valid-4 {
            background-color: #4060ff;
            /* Darker blue for 4 flips */
        }

        .ot_square.valid-5 {
            background-color: #2040ff;
            /* Dark blue for 5 flips */
        }

        .ot_square.valid-6,
        .ot_square.valid-7,
        .ot_square.valid-8 {
            background-color: #0020ff;
            /* Darkest blue for 6 or more flips */
        }
    </style>
    <script>
        let board;
        let canPl = true;
        let rst = false;

        document.addEventListener('DOMContentLoaded', async () => {
            const boardElement = document.getElementById('ot_board');

            function initializeBoard() {
                board = [
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, -1, 1, 0, 0, 0],
                    [0, 0, 0, 1, -1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]
                ];
            };

            initializeBoard();

            // Initialize board with squares
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                square.className = 'ot_square';
                square.addEventListener('click', () => handleSquareClick(i)); // Add event listener
                boardElement.appendChild(square);
            }
            // Initial update of the board display
            updateBoard();


            function updateBoard() {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const index = row * 8 + col;
                        const square = boardElement.children[index];
                        square.className = 'ot_square'; // Reset the class
                        if (board[row][col] === 1) {
                            square.classList.add('black');
                        } else if (board[row][col] === -1) {
                            square.classList.add('white');
                        } else if (canPl) {
                            const flips = countFlips(row, col, 1); // Check for valid moves for black
                            if (flips > 0) {
                                square.classList.add(`valid-${Math.min(flips, 6)}`); // Cap the class at valid-6
                            }
                        }
                    }
                }
            }

            function countFlips(row, col, player) {
                const directions = [
                    [0, 1], [1, 0], [0, -1], [-1, 0],
                    [1, 1], [1, -1], [-1, 1], [-1, -1]
                ];

                if (board[row][col] !== 0) return 0;
                let totalFlips = 0;
                for (const [dx, dy] of directions) {
                    let x = row + dx, y = col + dy;
                    let flips = 0;
                    while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                        if (board[x][y] === -player) {
                            flips++;
                        } else if (board[x][y] === player) {
                            totalFlips += flips;
                            break;
                        } else {
                            break;
                        }
                        x += dx;
                        y += dy;
                    }
                }
                return totalFlips;
            }


            function handleResetButtonClick() {
                initializeBoard();
                document.getElementById("result_ot").textContent = "";
                canPl = true;
                updateBoard();
                rst = true;
            }

            function wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            CPButton.addEventListener("click", async () => {
                canPl = false;
                if (rst) {
                    rst = false;
                }
                while (!isGameOver(board)) {
                    if (rst) {
                        initializeBoard();
                        updateBoard();
                        document.getElementById("result_ot").textContent = "";
                        rst = false;
                        return;
                    }
                    const cpStrange = parseInt(document.getElementById("ot_cpN").value) || 5;
                    do {
                        var cpu = await findBestMoveWithWorkers(board, 1, cpStrange, -Infinity, Infinity);
                        //var cpu = findBestMove(board, 1, 2, -Infinity, Infinity);
                        console.log(cpu);
                        if (Array.isArray(cpu)) {cpu = cpu[Math.floor(Math.random() * cpu.length)]}
                        if (cpu !== null && cpu.move) { board = placeAndFlip(board, cpu.move.row, cpu.move.col, 1) } else {
                            var lk = findBestMove3(board, 1, 4, -Infinity, Infinity);
                            if (lk.move !== null) {
                                board = placeAndFlip(board, lk.move.row, lk.move.col, 1)
                            } else {
                                var g = findRandomMove(board, 1);
                                if (g.move !== null) {
                                    board = placeAndFlip(board, g.move.row, g.move.col, 1)
                                } else {
                                    break;
                                }
                            }
                        }
                        // Update the board display
                        updateBoard();
                        console.log(output(re_board_converter(board)));
                        console.log(winning1(board));
                        if (isGameOver(board)) {
                            break;
                        }
                    } while (!canPlayerPlaceStone(board, -1))
                    if (isGameOver(board) || rst) {
                        break;
                    }
                    if (rst) {
                        initializeBoard();
                        updateBoard();
                        document.getElementById("result_ot").textContent = "";
                        rst = false;
                        return;
                    }
                    await wait(10);
                    do {
                        var cpu = await findBestMoveWithWorkers(board, -1, cpStrange, -Infinity, Infinity);
                        //var cpu = findBestMove4(board,-1,1,-Infinity,Infinity).move;
                        console.log(cpu);
                        if (cpu !== null && cpu.move) { board = placeAndFlip(board, cpu.move.row, cpu.move.col, -1) } else {
                            var lk = findBestMove2(board, -1, 4, -Infinity, Infinity);
                            if (lk.move !== null) {
                                board = placeAndFlip(board, lk.move.row, lk.move.col, -1)
                            } else {
                                var g = findRandomMove(board, -1);
                                if (g.move) {
                                    board = placeAndFlip(board, g.move.row, g.move.col, -1)
                                } else {
                                    break;
                                }
                            }
                        }
                        // Update the board display
                        updateBoard();
                        console.log(output(re_board_converter(board)));
                        console.log(winning1(board));
                        if (isGameOver(board)) {
                            break;
                        }
                    } while (!canPlayerPlaceStone(board, 1));
                    await wait(10);
                    if (isGameOver(board)) {
                        break;
                    }
                }
                document.getElementById("result_ot").textContent = winning1(board);
            });

            RDButton.addEventListener("click", async () => {
                canPl = false;
                if (rst) {
                    rst = false;
                }
                while (!isGameOver(board)) {
                    if (rst) {
                        initializeBoard();
                        updateBoard();
                        document.getElementById("result_ot").textContent = "";
                        rst = false;
                        return;
                    }
                    do {
                        var g = findRandomMove(board, 1);
                        if (g.move !== null) {
                            board = placeAndFlip(board, g.move.row, g.move.col, 1)
                        } else {
                            break;
                        }
                        // Update the board display
                        updateBoard();
                        console.log(output(re_board_converter(board)));
                        console.log(winning1(board));
                        if (isGameOver(board)) {
                            break;
                        }
                    } while (!canPlayerPlaceStone(board, -1))
                    if (isGameOver(board)) {
                        break;
                    }
                    await wait(1);
                    do {
                        var g = findRandomMove(board, -1);
                        if (g.move !== null) {
                            board = placeAndFlip(board, g.move.row, g.move.col, -1)
                        } else {
                            break;
                        }
                        // Update the board display
                        updateBoard();
                        console.log(output(re_board_converter(board)));
                        console.log(winning1(board));
                        if (isGameOver(board)) {
                            break;
                        }
                    } while (!canPlayerPlaceStone(board, 1));
                    await wait(1);
                    if (isGameOver(board)) {
                        break;
                    }
                }
                document.getElementById("result_ot").textContent = winning1(board);
            });


            resetButton.addEventListener('click', handleResetButtonClick);

            async function handleSquareClick(index) {
                const row = Math.floor(index / 8);
                const col = index % 8;
                console.log(`Square clicked: row ${row}, col ${col}`);


                // Example logic to place a piece (toggle between black and white for demonstration)
                if (canPlaceStone(board, row, col, 1) && canPl) {
                    canPl = false
                    board = placeAndFlip(board, row, col, 1);
                    updateBoard();
                    console.log(output(re_board_converter(board)));
                    if (isGameOver(board)) {
                        document.getElementById("result_ot").textContent = winning1(board);
                    } else {
                        do {
                            if (!canPlayerPlaceStone(board, -1)) {
                                break;
                            }
                            const cps = parseInt(document.getElementById("ot_cpN").value) || 5;
                            var cpu = await findBestMoveWithWorkers(board, -1, cps, -Infinity, Infinity);
                            //var cpu = findBestMove4s(board, -1, cps, -Infinity, Infinity);
                            console.log(2, cpu.move);
                            if (cpu !== null && cpu.move) { board = placeAndFlip(board, cpu.move.row, cpu.move.col, -1) } else {
                                var g = findBestMove(board, -1, 4, -Infinity, Infinity);
                                if (Array.isArray(g)) {g = g[Math.floor(Math.random() * g.length)]}
                                if (g.move !== null && !g) {
                                    board = placeAndFlip(board, g.move.row, g.move.col, -1)
                                } else {
                                    console.log("RANDOM")
                                    var g = findRandomMove(board, -1);
                                    if (g.move !== null) {
                                        board = placeAndFlip(board, g.move.row, g.move.col, -1)
                                    } else {
                                        break;
                                    }
                                }
                            }
                            // Update the board display
                            updateBoard();
                            console.log(output(re_board_converter(board)));
                            console.log(winning1(board));
                            if (isGameOver(board)) {
                                break;
                            }

                        } while (!canPlayerPlaceStone(board, 1))
                    }
                    canPl = true;
                    updateBoard();
                }
                if (isGameOver(board)) {
                    document.getElementById("result_ot").textContent = winning1(board);
                    canPl = true;
                }
            }
        });


        function findBestMove(board, player, depth, alpha, beta) {
            if (depth === 0 || isTerminalNode(board)) {
                return { score: evaluateBoard(board, player) };
            }
            let bestMove = [];
            if (player === 1) { // プレイヤー1の番
                let bestScore = -Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const testBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove(testBoard, -player, depth - 1, alpha, beta);
                            const score = -result.score;
                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = [{ row, col }];
                            } else if (score == bestScore) {
                                bestMove.push({ row, col });
                            }
                            alpha = Math.max(alpha, bestScore);
                            if (beta <= alpha) {
                                break;
                            }
                        }
                    }
                }
                return { move: bestMove, score: bestScore };
            } else { // プレイヤー2の番
                let bestScore = Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const testBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove(testBoard, -player, depth - 1, alpha, beta);
                            const score = -result.score;
                            if (score < bestScore) {
                                bestScore = score;
                                bestMove = [{ row, col }];
                            } else if (score == bestScore) {
                                bestMove.push({ row, col });
                            }
                            beta = Math.min(beta, bestScore);
                            if (beta <= alpha) {
                                break;
                            }
                        }
                    }
                }
                return { move: bestMove, score: bestScore };
            }
        }

        function evaluateBoard(board, player) {
            // 盤面の評価ロジックを実装する
            // 例: 石の数をカウントして評価
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === player) {
                        score++;
                    } else if (board[row][col] === -player) {
                        score--;
                    }
                }
            }
            return score;
        }

        function isGameOver(board) {
            return isBoardFull(board) || (!canPlayerPlaceStone(board, 1) && !canPlayerPlaceStone(board, -1));
        }

        function isTerminalNode(board) {
            // ゲームの終了条件を確認する
            // 例: 全てのマスが埋まった場合またはどちらかのプレイヤーが置ける場所がない場合
            return isBoardFull(board) || (!canPlayerPlaceStone(board, 1) && !canPlayerPlaceStone(board, -1));
        }

        function isBoardFull(board) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function canPlayerPlaceStone(board, player) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (canPlaceStone(board, row, col, player)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function canPlaceStone(board, row, col, player) {
            // マスが空でない場合は石を置けない
            if (board[row][col] !== 0) {
                return false;
            }

            // 8つの方向に対して調べる
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            let canFlip = false;

            for (const [dx, dy] of directions) {
                let x = row + dx;
                let y = col + dy;
                let flip = false;
                let stone_count = 0;

                while (x >= 0 && x < 8 && y >= 0 && y < 8) {

                    if (board[x][y] === 0) {
                        break;
                    }

                    if (board[x][y] != player) {
                        stone_count++;
                    }

                    if (board[x][y] == player && stone_count > 0) {
                        flip = true;
                        break;
                    }

                    if (board[x][y] == player && stone_count == 0) {
                        break;
                    }

                    x += dx;
                    y += dy;
                }

                if (flip) {
                    canFlip = true;
                    break;
                }
            }
            return canFlip;
        }

        function placeAndFlip(board, row, col, player) {
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],
                [-1, -1], [-1, 1], [1, -1], [1, 1]
            ];

            // 一時的に新しい盤面を作成して、石を置く
            const newBoard = board.map(row => [...row]);
            newBoard[row][col] = player;

            for (const [dx, dy] of directions) {
                let x = row + dx;
                let y = col + dy;
                let flip = false;
                let stone_count = 0;

                while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                    if (newBoard[x][y] === 0) {
                        break;
                    }

                    if (newBoard[x][y] != player) {
                        stone_count++;
                    }

                    if (newBoard[x][y] == player && stone_count > 0) {
                        flip = true;
                        break;
                    }

                    x += dx;
                    y += dy;
                }

                if (flip) {
                    // ひっくり返す処理
                    x = row + dx;
                    y = col + dy;
                    while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                        if (newBoard[x][y] === player) {
                            break;
                        }
                        newBoard[x][y] = player;
                        x += dx;
                        y += dy;
                    }
                }
            }

            return newBoard;
        }

        function re_board_converter(board) {
            //"⚫️" is 1 , "⚪️" is -1, blank is 0.
            let nb = [];
            for (let h = 0; h < 8; h++) {
                for (let wl = 0; wl < 8; wl++) {
                    var nt = board[h][wl];
                    if (nt == 1) {
                        nb.push("⚫️");
                    } else if (nt == -1) {
                        nb.push("⚪️");
                    } else if (nt == 0) {
                        nb.push((h * 8) + wl);
                    }
                }
            }
            return nb;
        }

        function zeroPadding(NUM, LEN) {
            return (Array(LEN).join("0") + NUM).slice(-LEN);
        }

        function output(board) {
            var t = board.map((x) => zeroPadding(x, 2)).toString();
            var g = t += ",";
            var h = g.replace(/,/g, ":").match(/.{24}/g).toString().replace(/,/g, "\n").replace(/:/g, " ");
            return h;
        }

        // パスの判定
        function isPass(board, player) {
            return findBestMove(board, player) === null;
        }

        function winning(board) {
            let [l, k] = [0, 0]
            for (let i = 0; i < 8; i++) {
                for (let h = 0; h < 8; h++) {
                    const element = board[i][h];
                    if (element == 1) {
                        l += 1;
                    } else if (element == -1) {
                        k += 1;
                    }
                }
            };
            return { "BLACK": l, "WHITE": k }
        }

        function winning1(board) {
            let winf;
            let [l, k] = [0, 0];
            for (let i = 0; i < 8; i++) {
                for (let h = 0; h < 8; h++) {
                    const element = board[i][h];
                    if (element == 1) {
                        l += 1;
                    } else if (element == -1) {
                        k += 1;
                    }
                }
            };
            var t = l + k;
            if (l > k) {
                winf = "WINNER: BLACK";
            } else if (k > l) {
                winf = "WINNER: WHITE";
            } else {
                winf = "DRAW"
            }
            return `BLACK: ${l}(${(l / t) * 100}%),\n WHITE: ${k}(${(k / t) * 100}%),\n${winf}`;
        }

        function iswin(board, player) {
            let g = winning(board);
            if ((g.BLACK > g.WHITE && player == -1) || (g.WHITE > g.BLACK && player == 1)) {
                return "WIN";
            } else if ((g.BLACK < g.WHITE && player == -1) || (g.WHITE < g.BLACK && player == 1)) {
                return "LOSE";
            } else if (g.BLACK == g.WHITE) {
                return "DRAW";
            } else {
                return "ERR";
            }
        }

        function findRandomMove(board, player) {
            console.log(board);
            let validMoves = [];

            // 有効な手を探す
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (canPlaceStone(board, row, col, player)) {
                        validMoves.push({ move: { row, col } });
                    }
                }
            }

            if (validMoves.length === 0) {
                return { bestMove: null }; // どこにも石を置けない場合
            }

            // 有効な手からランダムに選択
            const randomIndex = Math.floor(Math.random() * validMoves.length);
            return validMoves[randomIndex];
        }




        function findBestMove2(board, player, depth, alpha, beta) {
            if (depth === 0 || isGameOver(board)) {
                return { score: evaluateBoard2(board, player) };
            }

            let bestMove = null;
            if (player === 1) { // Maximizing player
                let maxEval = -Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove2(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval > maxEval) {
                                maxEval = eval;
                                bestMove = { row, col };
                            }
                            alpha = Math.max(alpha, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: maxEval };
            } else { // Minimizing player
                let minEval = Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove2(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval < minEval) {
                                minEval = eval;
                                bestMove = { row, col };
                            }
                            beta = Math.min(beta, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: minEval };
            }
        }

        function evaluateBoard2(board, player) {
            const weights = [
                [100, -20, 10, 5, 5, 10, -20, 100],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [10, -2, -1, -1, -1, -1, -2, 10],
                [5, -2, -1, -1, -1, -1, -2, 5],
                [5, -2, -1, -1, -1, -1, -2, 5],
                [10, -2, -1, -1, -1, -1, -2, 10],
                [-20, -50, -2, -2, -2, -2, -50, -20],
                [100, -20, 10, 5, 5, 10, -20, 100]
            ];

            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === player) {
                        score += weights[row][col];
                    } else if (board[row][col] === -player) {
                        score -= weights[row][col];
                    }
                }
            }

            // Add mobility score
            const playerMoves = countValidMoves(board, player);
            const opponentMoves = countValidMoves(board, -player);
            score += (playerMoves - opponentMoves);

            return score;
        }

        function countValidMoves(board, player) {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (canPlaceStone(board, row, col, player)) {
                        count++;
                    }
                }
            }
            return count;
        }


        function findBestMove3(board, player, depth, alpha, beta) {
            if (depth === 0 || isGameOver(board)) {
                return { score: evaluateBoard3(board, player) };
            }

            let bestMove = null;
            if (player === 1) { // Maximizing player
                let maxEval = -Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove3(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval > maxEval) {
                                maxEval = eval;
                                bestMove = { row, col };
                            }
                            alpha = Math.max(alpha, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: maxEval };
            } else { // Minimizing player
                let minEval = Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove3(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval < minEval) {
                                minEval = eval;
                                bestMove = { row, col };
                            }
                            beta = Math.min(beta, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: minEval };
            }
        }

        function evaluateBoard3(board, player) {
            const cornerWeight = 100; // 角の重み
            const edgeWeight = 10; // エッジの重み
            const mobilityWeight = 5; // モービリティの重み
            const stoneCountWeight = 1; // 石の数の重み

            const weights = [
                [cornerWeight, -edgeWeight, 10, 5, 5, 10, -edgeWeight, cornerWeight],
                [-edgeWeight, -edgeWeight, 2, 2, 2, 2, -edgeWeight, -edgeWeight],
                [10, 2, 1, 1, 1, 1, 2, 10],
                [5, 2, 1, 0, 0, 1, 2, 5],
                [5, 2, 1, 0, 0, 1, 2, 5],
                [10, 2, 1, 1, 1, 1, 2, 10],
                [-edgeWeight, -edgeWeight, 2, 2, 2, 2, -edgeWeight, -edgeWeight],
                [cornerWeight, -edgeWeight, 10, 5, 5, 10, -edgeWeight, cornerWeight]
            ];

            let score = 0;

            // 角の評価
            score += cornerWeight * (board[0][0] === player) + (board[0][7] === player) +
                (board[7][0] === player) + (board[7][7] === player);

            // エッジの評価
            for (let row = 0; row < 8; row++) {
                score += edgeWeight * (board[row][0] === player) + (board[row][7] === player);
                score += edgeWeight * (board[0][row] === player) + (board[7][row] === player);
            }

            // モービリティの評価
            const playerMoves = countValidMoves(board, player);
            const opponentMoves = countValidMoves(board, -player);
            score += mobilityWeight * (playerMoves - opponentMoves);

            // 石の数の評価
            const playerStones = countStones(board, player);
            const opponentStones = countStones(board, -player);
            score += stoneCountWeight * (playerStones - opponentStones);

            return score;
        }

        function countStones(board, player) {
            let count = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === player) {
                        count++;
                    }
                }
            }
            return count;
        }

        const workers = [];
        const workerPromises = [];

        let worker_js = `
self.onmessage = function(e) {
    const { board, player, depth, alpha, beta, startIndex, endIndex } = e.data;
    const result = findBestMove(board, player, depth, alpha, beta, startIndex, endIndex);
    self.postMessage(result);
  };
  
  function findBestMove(board, player, depth, alpha, beta, startIndex, endIndex) {
    if (depth === 0 || isGameOver(board)) {
      return { score: evaluateBoard(board, player) };
    }
  
    let bestMove = null;
    let maxEval = -Infinity;
    let minEval = Infinity;
  
    for (let row = startIndex; row <= endIndex; row++) {
      for (let col = 0; col < 8; col++) {
        if (canPlaceStone(board, row, col, player)) {
          const newBoard = placeAndFlip(board, row, col, player);
          const result = findBestMove(newBoard, -player, depth - 1, alpha, beta, 0, 7);
          const eval = result.score;
  
          if (player === 1) { // Maximizing player
            if (eval > maxEval) {
              maxEval = eval;
              bestMove = { row, col };
            }
            alpha = Math.max(alpha, eval);
          } else { // Minimizing player
            if (eval < minEval) {
              minEval = eval;
              bestMove = { row, col };
            }
            beta = Math.min(beta, eval);
          }
          if (beta <= alpha) break;
        }
      }
    }
  
    return player === 1 ? { move: bestMove, score: maxEval } : { move: bestMove, score: minEval };
  }
  
  const EMPTY = 0;
  const BLACK = 1;
  const WHITE = -1;
  
  const weights = [[16.661323287781027, -1.3273627858107817, 3.3915601176541186, 2.625155068230023, 2.8471388555422195, 3.465802217152919, -0.9551972940246345, 15.502200920476078], [-1.4360052036425541, -0.5287167738772913, 1.3239898762542168, 1.232906859263555, 0.8012243428159871, 1.435030961455741, -0.37917442023330805, -0.9725446249899905], [3.877167181888214, 1.176935466122464, 3.3661395665176395, 0.27854178126718865, 2.2607939032074142, 2.3165559734336263, 1.7365556978233054, 3.7006282764416367], [2.5694506967578024, 1.5255186763499573, 0.4085449399433949, -0.0, -0.0, 1.979836572217275, 0.8072744733209292, 2.7902277001880806], [3.068227290916364, 0.7227095857798738, 2.5217773955135083, -0.0, -0.0, 0.5866114561766722, 1.7320369314487494, 2.624102122891614], [3.187551892124402, 1.4869907069332888, 1.9868377624196132, 2.1493438950232036, 0.22903664586333972, 3.4184785870021828, 1.4169109041622052, 3.4625235103445506], [-0.7744956772334333, -0.6122571480021599, 1.6380733256639801, 0.8528326047158419, 1.467955066070481, 1.2203905249679903, -0.5917070974841177, -1.1953486975752825], [15.394292358737383, -0.689468838810392, 3.7456480851574714, 2.8787954579560795, 2.688709919463761, 3.5605666493257027, -1.36487351905219, 16.556792337517912]];
  
  function evaluateBoard(board) {
    let stabilityScore = evaluateStability(board);
    //let mobilityScore = evaluateMobility(board);
    //let frontierScore = evaluateFrontier(board);
  
    // 評価関数の重みを設定
    const stabilityWeight = 1.0;
    const mobilityWeight = 12.0;
    const frontierWeight = 210.5;
  
    // 各評価を総合する
    /*return (
      stabilityWeight * stabilityScore +
      mobilityWeight * mobilityScore +
      frontierWeight * frontierScore
    );*/
    return stabilityScore;
  }

  function reLUF(x) {
    //return x < 0 ?  Math.cbrt(x) * 100 : - Math.exp(-x * 100);
    return Math.sinh(x);
  }
  
  function evaluateStability(board) {
    let score = 0;
  
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === BLACK) {
          score += reLUF(weights[row][col]);
        } else if (board[row][col] === WHITE) {
          score -= reLUF(weights[row][col]);
        }
      }
    }
  
    return score;
  }
  
  function evaluateMobility(board) {
    let blackMobility = countPotentialMoves(board, BLACK);
    let whiteMobility = countPotentialMoves(board, WHITE);
  
    return blackMobility - whiteMobility;
  }
  
  function countPotentialMoves(board, player) {
    let directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],         [0, 1],
      [1, -1], [1, 0], [1, 1]
    ];
    let count = 0;
  
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === EMPTY) {
          for (let [dx, dy] of directions) {
            let x = row + dx, y = col + dy;
            if (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === (player === BLACK ? WHITE : BLACK)) {
              count++;
              break;
            }
          }
        }
      }
    }
  
    return count;
  }
  
  function evaluateFrontier(board) {
    let blackFrontier = countFrontierDiscs(board, BLACK);
    let whiteFrontier = countFrontierDiscs(board, WHITE);
  
    return whiteFrontier - blackFrontier; // フロンティアは少ない方が有利
  }
  
  function countFrontierDiscs(board, player) {
    let directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],         [0, 1],
      [1, -1], [1, 0], [1, 1]
    ];
    let count = 0;
  
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === player) {
          for (let [dx, dy] of directions) {
            let x = row + dx, y = col + dy;
            if (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === EMPTY) {
              count++;
              break;
            }
          }
        }
      }
    }
  
    return count;
  }
  
  function countValidMoves(board, player) {
    let count = 0;
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (canPlaceStone(board, row, col, player)) {
          count++;
        }
      }
    }
    return count;
  }
  
  function countStones(board, player) {
    let count = 0;
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === player) {
          count++;
        }
      }
    }
    return count;
  }
  
  function isGameOver(board) {
    return isBoardFull(board) || (!canPlayerPlaceStone(board, 1) && !canPlayerPlaceStone(board, -1));
  }
  
  function isBoardFull(board) {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === 0) {
          return false;
        }
      }
    }
    return true;
  }
  
  function canPlayerPlaceStone(board, player) {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (canPlaceStone(board, row, col, player)) {
          return true;
        }
      }
    }
    return false;
  }
  
  function isGameOver(board) {
    return isBoardFull(board) || (!canPlayerPlaceStone(board, 1) && !canPlayerPlaceStone(board, -1));
  }
  
  function isBoardFull(board) {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] === 0) {
          return false;
        }
      }
    }
    return true;
  }
  
  function canPlayerPlaceStone(board, player) {
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (canPlaceStone(board, row, col, player)) {
          return true;
        }
      }
    }
    return false;
  }
  
  function canPlaceStone(board, row, col, player) {
    // マスが空でない場合は石を置けない
    if (board[row][col] !== 0) {
        return false;
    }

    // 8つの方向に対して調べる
    const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [-1, 1], [1, -1], [1, 1]
    ];

    let canFlip = false;

    for (const [dx, dy] of directions) {
        let x = row + dx;
        let y = col + dy;
        let flip = false;
        let stone_count = 0;

        while (x >= 0 && x < 8 && y >= 0 && y < 8) {

            if (board[x][y] === 0) {
                break;
            }

            if (board[x][y] != player) {
                stone_count++;
            }

            if (board[x][y] == player && stone_count > 0) {
                flip = true;
                break;
            }

            if (board[x][y] == player && stone_count == 0) {
                break;
            }

            x += dx;
            y += dy;
        }

        if (flip) {
            canFlip = true;
            break;
        }
    }
    return canFlip;
}

function placeAndFlip(board, row, col, player) {
    const directions = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [-1, 1], [1, -1], [1, 1]
    ];

    // 一時的に新しい盤面を作成して、石を置く
    const newBoard = board.map(row => [...row]);
    newBoard[row][col] = player;

    for (const [dx, dy] of directions) {
        let x = row + dx;
        let y = col + dy;
        let flip = false;
        let stone_count = 0;

        while (x >= 0 && x < 8 && y >= 0 && y < 8) {
            if (newBoard[x][y] === 0) {
                break;
            }

            if (newBoard[x][y] != player) {
                stone_count++;
            }

            if (newBoard[x][y] == player && stone_count > 0) {
                flip = true;
                break;
            }

            x += dx;
            y += dy;
        }

        if (flip) {
            // ひっくり返す処理
            x = row + dx;
            y = col + dy;
            while (x >= 0 && x < 8 && y >= 0 && y < 8) {
                if (newBoard[x][y] === player) {
                    break;
                }
                newBoard[x][y] = player;
                x += dx;
                y += dy;
            }
        }
    }

    return newBoard;
}
  
  `


        let bl = new Blob([worker_js], { type: 'text/javascript' })

        async function findBestMoveWithWorkers(board, player, depth) {
            const numCores = parseInt(document.getElementById("ot_th").value) || navigator.hardwareConcurrency || 4;
            const rowRangeSize = Math.ceil(8 / numCores);
            const workerPromises = []; // 新しい空の配列を生成

            for (let i = 0; i < numCores; i++) {
                const startIndex = i * rowRangeSize;
                const endIndex = Math.min((i + 1) * rowRangeSize - 1, 7);
                workerPromises.push(new Promise((resolve) => {
                    const worker = new Worker(URL.createObjectURL(bl));
                    worker.onmessage = function (e) {
                        resolve(e.data);
                        worker.terminate(); // Workerを終了させる
                    };
                    worker.postMessage({ board, player, depth, startIndex, endIndex });
                }));
            }

            const results = await Promise.all(workerPromises);
            let bestMove = [];
            let bestScore = player === 1 ? -Infinity : Infinity;
            results.forEach(result_1 => {
                if (result_1.move && result_1.score !== null) { // nullの結果を無視する
                    if (player === 1 && result_1.score > bestScore) {
                        bestScore = result_1.score;
                        bestMove = [result_1.move];
                    } else if (player === -1 && result_1.score < bestScore) {
                        bestScore = result_1.score;
                        bestMove = [result_1.move];
                    } else if (player === -1 && result_1.score == bestScore) {
                        bestScore = result_1.score;
                        bestMove.push(result_1.move);
                    } else if (player === 1 && result_1.score == bestScore) {
                        bestScore = result_1.score;
                        bestMove.push(result_1.move);
                    }
                }
            });
            let h = bestMove[Math.floor(Math.random() * bestMove.length)];
            console.log({move:h,score:bestScore});
            return {move:h,score:bestScore};
        }

        function findBestMove4s(board, player, depth, alpha, beta) {
            return findBestMove4(board, player, depth, alpha, beta).move;
        }

        function findBestMove4(board, player, depth, alpha, beta) {
            if (depth === 0 || isGameOver(board)) {
                return { score: evaluateBoard4(board, player) };
            }

            let bestMove = null;
            if (player === 1) { // Maximizing player
                let maxEval = -Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove4(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval > maxEval) {
                                maxEval = eval;
                                bestMove = { row, col };
                            }
                            alpha = Math.max(alpha, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: maxEval };
            } else { // Minimizing player
                let minEval = Infinity;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (canPlaceStone(board, row, col, player)) {
                            const newBoard = placeAndFlip(board, row, col, player);
                            const result = findBestMove3(newBoard, -player, depth - 1, alpha, beta);
                            const eval = result.score;
                            if (eval < minEval) {
                                minEval = eval;
                                bestMove = { row, col };
                            }
                            beta = Math.min(beta, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { move: bestMove, score: minEval };
            }
        }

        function evaluateBoard4(board, player) {
            const weights = [[16.64195477724235, -1.2692996587850391, 3.790129755794991, 2.6156770546746033, 3.0413990435600393, 3.4345111849213628, -1.0372571977543599, 15.823127342700793], [-1.091807937874023, -0.6822865603553496, 1.7281048366928398, 1.3234499729908145, 0.9018336784610281, 1.7556671535183366, -0.317668364233048, -0.8700655426026938], [3.871703549561806, 1.295440449752916, 3.22558060450881, 0.5580558055805596, 2.17626115133816, 2.1510807918137917, 1.5850230576090085, 3.3785541349020565], [2.767162208127416, 1.5105135746153686, 0.15552332849927408, -0.0, -0.0, 2.2963214850079017, 0.9623271912450215, 2.9087507628280163], [3.0419297069622706, 1.0889028940708034, 2.2827967635792645, -0.0, -0.0, 0.5375806370955638, 1.2794606058180946, 2.496148228184963], [3.273103820872225, 1.5991236582267088, 2.257677303190958, 2.4244848969793953, 0.45058561126614105, 3.1665699825968674, 1.5915411239821542, 3.8353025922183424], [-1.0968116406140593, -0.4867482416032187, 1.7992376874518545, 0.7707851905204899, 1.4380320718665907, 1.6700177054887022, -0.9933774834437137, -1.2527265814172184], [15.539741405232032, -0.7865663277559887, 3.452122497573862, 2.9248161672752735, 2.747681503046312, 3.7827400604277974, -1.0272087740541003, 16.55544199282551]].map(x => Math.cbrt(x) * 100);

            let score = 0;

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === BLACK) {
                        score *= weights[row][col];
                    } else if (board[row][col] === WHITE) {
                        score /= weights[row][col];
                    }
                }
            }
            return player * score;
        }
    </script>
</head>

<body>
    <div class="app-containers" id="appContainers">
        <div id="container15" class="container" style="left: 300px; top: 50px; z-index: 15">

            <div class="modal-content">
                <h2>Reversi</h2>
                <div id="ot_app">
                    <div id="ot_board"></div>
                </div>
                <button id="resetButton" class="button">リセット</button><button id="CPButton"
                    class="button">CPUに任せる</button>
                <button id="RDButton" class="button">ランダム</button>
                <button id="STButton" class="button" onclick="openSettings()">設定</button>
                <p id="result_ot"></p>
            </div>
        </div>
        <div id="container17" class="container" style="width: 100vw;height: 100vh; display: none;" z-index="2">
            <div class="modal-howto">
                <h1 style="padding: 30px; user-select: none;">設定</h1>
                <p>
                <h2>CPUの強さ(何手先まで読むか):</h2>
                </p>
                <p><input type="number" id="ot_cpN" value="5" placeholder="整数を入力"></p>
                <p>
                <h2>スレッド数:</h2>
                </p>
                <p><input type="number" id="ot_th" placeholder="整数を入力"></p>
                <p><button onclick="closeSettings();" id="apply">設定を適用して閉じる</button></p>
            </div>
        </div>

    </div>

    <footer>
        <p id="version_info">Reversi (Version 1.0.0) &emsp; © 2025 dedot-3799.</p>
    </footer>
</body>
<script>
    function openSettings() {
        document.getElementById('container17').style.display = 'flex'
        document.getElementById("container15").style.display = "none";
    }
    function closeSettings() {
        document.getElementById('container15').style.display = 'flex'
        document.getElementById("container17").style.display = "none";
    }
</script>

</html>
